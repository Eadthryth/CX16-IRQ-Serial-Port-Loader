; X16 ADDRESSES, VALUES, AND MACROS
; ACCURATE FOR ROM RELEASE R47

SD_DEVICE   := 8
DISK_DEVICE := SD_DEVICE ; CHANGE IF LOADING FROM IEC DEVICE

; ------------------------------------
; KERNAL VECTORS
; ------------------------------------

; STANDARD VECTORS
CINV    := $0314 ; IRQ INTERRUPT ROUTINE
CBINV   := $0316 ; BRK INSTRUCTION INTERRUPT
NMINV   := $0318 ; NON-MASKABLE INTERRUPT
IOPEN   := $031A ; KERNAL OPEN ROUTINE
ICLOSE  := $031C ; KERNAL CLOSE ROUTINE
iCHKIN  := $031E ; KERNAL CHKIN ROUTINE
ICKOUT  := $0320 ; KERNAL CKOUT ROUTINE
ICLRCH  := $0322 ; KERNAL CLRCHN ROUTINE
IBASIN  := $0324 ; KERNAL CHRIN ROUTINE
IBSOUT  := $0326 ; KERNAL CHROUT ROUTINE
ISTOP   := $0328 ; KERNAL STOP ROUTINE
IGETIN  := $032A ; KERNAL GETIN ROUTINE
ICLALL  := $032C ; KERNAL CLALL ROUTINE
ILOAD   := $0330 ; KERNAL LOAD ROUTINE
ISAVE   := $0332 ; KERNAL SAVE ROUTINE

; 65C816 VECTORS
IECOP   := $0334 ; COP INSTRUCTION INTERRUPT ROUTINE (EMULATION MODE)
IEABORT := $0336 ; ABORT ROUTINE (EMULATION MODE)
INIRQ   := $0338 ; IRQ INTERRUPT ROUTINE (NATIVE MODE)
INBRK   := $033A ; BRK INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
INNMI   := $033C ; NON-MASKABLE INTERRUPT ROUTINE (NATIVE MODE)
INCOP   := $033E ; COP INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
INABORT := $0340 ; ABORT ROUTINE (NATIVE MODE)

; FRAMEBUFFER VECTORS
I_FB_INIT                   := $02E4 ; FRAMEBUFFER ENABLE ROUTINE
I_FB_GET_INFO               := $02E6 ; FRAMEBUFFER INFO ROUTINE
I_FB_SET_PALETTE            := $02E8 ; FRAMEBUFFER PALETTE ROUTINE
I_FB_CURSOR_POSITION        := $02EA ; FRAMEBUFFER CURSOR POSITION ROUTINE
I_FB_CURSOR_NEXT_LINE       := $02EC ; FRAMEBUFFER NEXT LINE ROUTINE
I_FB_GET_PIXEL              := $02EE ; FRAMEBUFFER COPY PIXEL ROUTINE
I_FB_GET_PIXELS             := $02F0 ; FRAMEBUFFER COPY PIXELS ROUTINE
I_FB_SET_PIXEL              := $02F2 ; FRAMEBUFFER SET PIXEL ROUTINE
I_FB_SET_PIXELS             := $02F4 ; FRAMEBUFFER SET PIXELS ROUTINE
I_FB_SET_8_PIXELS           := $02F6 ; FRAMEBUFFER SET 8 PIXELS ROUTINE
I_FB_SET_8_PIXELS_OPAQUE    := $02F8 ; FRAMEBUFFER SET 8 OPAQUE PIXELS ROUTINE
I_FB_FILL_PIXELS            := $02FA ; FRAMEBUFFER FILL PIXELS ROUTINE
I_FB_FILTER_PIXELS          := $02FC ; FRAMEPUFFER TRANSFORM PIXELS ROUTINE
I_FB_MOVE_PIXELS            := $02FE ; FRAMEBUFFER MOVE PIXELS ROUTINE

; ------------------------------------
; KERNAL API FUNCTIONS
; ------------------------------------

; PERIPHERAL BUS
ACPTR   := $FFA5 ; READ A BYTE FROM THE PERIPHERAL BUS
MACPTR  := $FF44 ; READ MULTIPLE BYTES FROM THE PERIPHERAL BUS
MCIOUT  := $FEB1 ; WRITE MULTIPLE BYTES TO THE PERIPHERAL BUS

; CHANNEL I/O
BSAVE   := $FEBA ; SAVE AN AREA OF MEMORY TO A FILE WITHOUT WRITING AN ADDRESS HEADER
CLOSE   := $FFC3 ; CLOSE A LOGICAL FILE
LOAD    := $FFD5 ; LOAD THE CONTENTS OF A FILE FROM DISK TO MEMORY
OPEN    := $FFC0 ; OPENS A CHANNEL/FILE
SAVE    := $FFD8 ; SAVE AN AREA OF MEMORY TO A FILE
SETFLS  := $FFBA ; SET FILE PARAMETERS
SETNAM  := $FFBD ; SET FILE NAME

; MEMORY
MEMORY_FILL         := $FEE4 ; FILL MEMORY REGION WITH A BYTE VALUE
MEMORY_COPY         := $FEE7 ; COPY MEMORY REGION
MEMORY_CRC          := $FEEA ; CALCULATE CRC16 OF MEMORY REGION
MEMORY_DECOMPRESS   := $FEED ; DECOMPRESS LZSA2 BLOCK
FETCH               := $FF74 ; READ A BYTE FROM ANY RAM OR ROM BANK
STASH               := $FF77 ; WRITE A BYTE TO ANY RAM BANK
MEMTOP              := $FF99 ; GET NUMBER OF BANKS AND ADDRESS OF END OF USABLE RAM

; CLOCK
CLOCK_SET_DATE_TIME := $FF4D ; SET DATE AND TIME OF THE RTC
CLOCK_GET_DATE_TIME := $FF50 ; GET DATE AND TIME FROM THE RTC
RDTIM               := $FFDE ; READ SYSTEM CLOCK FROM THE VIA

; KEYBOARD
KBDBUF_PEEK             := $FEBD ; GET FIRST CHARACTER IN KEYBOARD QUEUE AND QUEUE LENGTH
KBDBUF_GET_MODIFIERS    := $FEC0 ; GET CURRENTLY PRESSED MODIFIER KEYS
KBDBUF_PUT              := $FEC3 ; APPEND A CHARACTER TO THE KEYBOARD QUEUE
KEYMAP                  := $FED2 ; SET OR GET THE CURRENT KEYBOARD LAYOUT
KBD_SCAN                := $FF9F ; READ A KEYCODE PREVIOUSLY FETCHED FROM THE SMC, APPLY KEYMAP LOCALIZATION, AND ADD IT THE THE X16'S BUFFER

; MOUSE
MOUSE_CONFIG    := $FF68 ; CONFIGURE THE MOUSE POINTER
MOUSE_SCAN      := $FF71 ; QUERY THE MOUSE AND SAVE ITS STATE
MOUSE_GET       := $FF6B ; GET THE MOUSE STATE

; JOYSTICK
JOYSTICK_SCAN   := $FF53 ; QUERY THE JOYSTICKS AND SAVE THEIR STATE
JOYSTICK_GET    := $FF56 ; GET THE STATE OF ONE OF THE JOYSTICKS

; I2C
I2C_BATCH_READ  := $FEB4 ; READ BYTES FROM A GIVE I2C DEVICE INTO A RAM LOCATION
I2C_BATCH_WRITE := $FEB7 ; WRITE BYTES TO A GIVEN I2C DEVICE WITH DATA IN RAM
I2C_READ_BYTE   := $FEC6 ; READ A BYTE AT A GIVEN OFFSET FROM A GIVEN I2C DEVICE
I2C_WRITE_BYTE  := $FEC9 ; WRITE A BYTE AT A GIVEN OFFSET TO A GIVEN I2C DEVICE

; SPRITES
SPRITE_SET_IMAGE    := $FEF0 ; SET THE IMAGE OF A SPRITE
SPRITE_SET_POSITION := $FEF3 ; SET THE POSITION OF A SPRITE OR HIDE IT

; FRAMEBUFFER
FB_INIT                 := $FEF6 ; ENTER GRAPHICS MODE
FB_GET_INFO             := $FEF9 ; RETURN THE RESOLUTION AND COLOR DEPTH
FB_SET_PALETTE          := $FEFC ; SET (PARTS OF) THE PALETTE
FB_CURSOR_POSITION      := $FEFF ; POSITION THE DIRECT-ACCESS CURSOR
FB_CURSOR_NEXT_LINE     := $FF02 ; MOVE THE DIRECT-ACCESS CURSOR TO THE NEXT LINE
FB_GET_PIXEL            := $FF05 ; READ ONE PIXEL, UPDATE CURSOR
FB_GET_PIXELS           := $FF08 ; COPY PIXELS INTO RAM, UPDATE CURSOR
FB_SET_PIXEL            := $FF0B ; SET ONE PIXEL, UPDATE CURSOR
FB_SET_PIXELS           := $FF0E ; COPY PIXELS FROM RAM, UPDATE CURSOR
FB_SET_8_PIXELS         := $FF11 ; SET 8 PIXELS FROM BIT MASK (TRANSPARENT), UPDATE CURSOR
FB_SET_8_PIXELS_OPAQUE  := $FF14 ; SET 8 PIXELS FROM BIT MASK (OPAQUE), UPDATE CURSOR
FB_FILL_PIXELS          := $FF17 ; FILL PIXELS WITH CONSTANT COLOR, UPDATE CURSOR
FB_FILTER_PIXELS        := $FF1A ; APPLY TRANSFORM TO PIXELS, UPDATE CURSOR
FB_MOVE_PIXELS          := $FF1D ; COPY HORIZONTALLY CONSECUTIVE PIXELS TO A DIFFERENT POSITION

; GRAPHICS
GRAPH_INIT          := $FF02 ; ACTIVATE FRAMEBUFFER DRIVER, ENTER AND INITIALIZE GRAPHICS MODE
GRAPH_CLEAR         := $FF23 ; CLEAR THE CURRENT WINDOW WITH THE CURRENT BACKGROUND COLOR
GRAPH_SET_WINDOW    := $FF26 ; SET THE CLIPPING REGION
GRAPH_SET_COLORS    := $FF29 ; SET THE THREE COLORS
GRAPH_DRAW_LINE     := $FF2C ; DRAW A LINE USING THE STROKE COLOR
GRAPH_DRAW_RECT     := $FF2F ; DRAW A RECTANGLE
GRAPH_MOVE_RECT     := $FF23 ; COPY A RECTANGLULAR SCREEN AREA TO A DIFFERENT LOCATION
GRAPH_DRAW_OVAL     := $FF35 ; DRAW AN OVAL OR A CIRCLE
GRAPH_DRAW_IMAGE    := $FF38 ; DRAW A RECTANGULAR IMAGE FROM DATA IN MEMORY
GRAPH_SET_FONT      := $FF3B ; SET THE CURRENT FONT
GRAPH_GET_CHAR_SIZE := $FF3E ; GET THE SIZE AND BASELINE OF A CHARACTER, OR INTERPRET A CONTROL CODE
GRAPH_PUT_CHAR      := $FF41 ; PRINT A CHARACTER ONTO THE GRAPHICS SCREEN

; CONSOLE
CONSOLE_INIT                := $FEDB ; INITIALIZE CONSOLE MODE
CONSOLE_PUT_CHAR            := $FEDE ; PRINT A CHARACTER TO THE CONSOLE
CONSOLE_PUT_IMAGE           := $FED8 ; DRAW IMAGE AS IF IT WAS A CHARACTER
CONSOLE_GET_CHAR            := $FEE1 ; GET A CHARACTER FROM THE CONSOLE
CONSOLE_SET_PAGING_MESSAGE  := $FED5 ; SET THE PAGING MESSAGE OR DISABLE PAGING

; MISC
ENTER_BASIC         := $FF47 ; ENTER BASIC
ENTROPY_GET         := $FECF ; GET 24 RANDOM BITS
MONITOR             := $FECC ; ENTER MACHINE LANGUAGE MONITOR
SCREEN_MODE         := $FF5F ; GET/SET SCREEN MODE
SCREEN_SET_CHARSET  := $FF62 ; ACTIVATE 8x8 TEXT MODE CHARSET
SCREEN              := $FFED ; GET THE TEXT RESOLUTION OF THE SCREEN

; EXTENDED API
EXTAPI                  := $FEAB ; EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
; A-VALUES
CLEAR_STATUS            := $01 ; RESETS THE KERNAL IEC STATUS TO ZERO
GETLFS                  := $02 ; GETTER COUNTERPART TO SETLFS
MOUSE_SPRITE_OFFSET     := $03 ; GET OR SET MOUSE SPRITE PIXEL OFFSET
JOYSTICK_PS2_KEYCODES   := $04 ; GET OR SET JOY0 KEYCODE MAPPINGS
ISO_CURSOR_CHAR         := $05 ; GET OR SET THE ISO MODE CURSOR CHARACTER
PS2KBD_TYPEMATIC        := $06 ; SET THE KEYBOARD REPEAT DELAY AND RATE
PFKEY                   := $07 ; PROGRAM MACROS FOR THE F1-F8 AND THE RUN KEY
PS2DATA_FETCH           := $08 ; POLLS THE SMC FOR PS/2 KEYBOARD AND MOUSE DATA
FS2DATA_RAW             := $09 ; IF THE POST RECENT PS2DATA_FETCH RECEIVED A MOUSE PACKET OR KEYCODE, RETURNS ITS RAW VALUE
CURSOR_BLINK            := $0A ; BLINKS OR UN-BLINKS THE KERNAL EDITOR CURSOR IF APPROPRIATE
LED_UPDATE              := $0B ; ILLUMINATES OR CLEARS THE SMC ACTIVITY LED BASED ON DISK ACTIVITY OR ERROR STATUS
MOUSE_SET_POSITION      := $0C ; MOVES THE MOUSE CURSOR TO A SPECIFIC X/Y LOCATION
SCNSIZ                  := $0D ; DIRECTLY SETS THE KERNAL EDITOR TEXT DIMENSIONS

; 65C816 EXTENDED API
EXTAPI16                := $FEA8 ; 65C816 EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
; A-VALUES
TEST                        := $00 ; USED BY UNIT TESTS FOR JSRFAR
STACK_PUSH                  := $01 ; POINTS THE STACK POINTER TO A NEW STACK
STACK_POP                   := $02 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED STACK
STACK_ENTER_KERNAL_STACK    := $03 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED $01xx STACK, PRESERVING THE CURRENT ONE
STACK_LEAVE_KERNAL_STACK    := $04 ; POINT THE STACK POINTER TO THE PREVIOUSLY-PRESERVED STACK

; ------------------------------------
; I/O REGISTERS
; ------------------------------------

; VERA REGISTERS
VERA_L			= $9F20
VERA_M			= $9F21
VERA_H			= $9F22
VERA_DATA0		= $9F23
VERA_DATA1      = $9F24
VERA_CTRL       = $9F25
VERA_IEN 		= $9F26
VERA_ISR 		= $9F27
VIDEO_CONFIG	= $9F29 ; (DCSEL = 0)
L0_CONFIG 		= $9F2D
L0_MAPBASE		= $9F2E
L0_TILEBASE		= $9F2F
L0_HSCROLL_L	= $9F30
L0_HSCROLL_H	= $9F31
L0_VSCROLL_L	= $9F32
L0_VSCROLL_H	= $9F33
L1_CONFIG 		= $9F34
L1_MAPBASE 		= $9F35
L1_TILEBASE		= $9F36
L1_HSCROLL_L	= $9F37
L1_HSCROLL_H	= $9F38
L1_VSCROLL_L	= $9F39
L1_VSCROLL_H	= $9F3A

