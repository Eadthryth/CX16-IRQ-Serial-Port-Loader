ca65 V2.19 - Git b1e1c13d4
Main file   : ./src/main.asm
Current file: ./src/main.asm

000000r 1               .INCLUDE "macros.inc"
000000r 2               ;MACRO LOAD_FILE (FILE LENGTH),(<FILE NAME),(>FILE NAME),(<LOAD LOCATION),(>LOAD LOCATION),(^LOAD LOCATION)
000000r 2               .MACRO LOAD_FILE LENGTH,X_NAME,Y_NAME,X_LOCATION,Y_LOCATION,A_LOCATION
000000r 2               	LDA LENGTH	;LENGTH OF FILE NAME
000000r 2               	LDX X_NAME
000000r 2               	LDY Y_NAME
000000r 2               	JSR SETNAM	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
000000r 2               	LDA #$01
000000r 2               	LDX #$08
000000r 2               	LDY #$00
000000r 2               	JSR SETFLS	;SETLFS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
000000r 2               	LDX X_LOCATION
000000r 2               	LDY Y_LOCATION
000000r 2               	LDA A_LOCATION	;LOAD FILE INTO A=1 RAM, A=2 VRAM FOR $0:0000, A=3 VRAM FOR $1:0000
000000r 2               	JSR LOAD	;LOAD FILE FOR LOAD X/Y=LOAD ADDRESS
000000r 2               	LDA #$01
000000r 2               	JSR CLOSE	;CLOSE FILE
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ;MACRO SAVE_FILE (FILE LENGTH),(<FILE NAME),(>FILE NAME),(<LOAD LOCATION),(>LOAD LOCATION),(^LOAD LOCATION)
000000r 2               .MACRO SAVE_FILE LENGTH,X_NAME,Y_NAME,X_LOCATION,Y_LOCATION,A_LOCATION
000000r 2               	LDA LENGTH	;LENGTH OF FILE NAME
000000r 2               	LDX X_NAME
000000r 2               	LDY Y_NAME
000000r 2               	JSR SETNAM	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
000000r 2               	LDA #$01
000000r 2               	LDX #$08
000000r 2               	LDY #$02
000000r 2               	JSR SETFLS	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
000000r 2               	LDX X_LOCATION
000000r 2               	LDY Y_LOCATION
000000r 2               	LDA A_LOCATION	;ZERO PAGE POINTER TO START ADDRESS
000000r 2               	JSR SAVE	;SAVE FILE TO X/Y=END ADDRESS
000000r 2               	LDA #$01
000000r 2               	JSR CLOSE	;CLOSE FILE
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ;MACRO APPEND_FILE (FILE LENGTH),(<FILE NAME),(>FILE NAME),(<LOAD LOCATION),(>LOAD LOCATION),(^LOAD LOCATION)
000000r 2               ;FILE NAME MUST HAVE ",S,A" AT THE END OF IT FOR APPENDING TO WORK
000000r 2               .MACRO APPEND_FILE LENGTH,X_NAME,Y_NAME,X_LOCATION,Y_LOCATION,A_LOCATION
000000r 2               	LDA LENGTH	;LENGTH OF FILE NAME
000000r 2               	LDX X_NAME
000000r 2               	LDY Y_NAME
000000r 2               	JSR SETNAM	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
000000r 2               	LDA #$01
000000r 2               	LDX #$08
000000r 2               	LDY #$02
000000r 2               	JSR SETFLS	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
000000r 2               	JSR OPEN	;OPEN FILE FOR WRITING
000000r 2               	LDX X_LOCATION
000000r 2               	LDY Y_LOCATION
000000r 2               	LDA A_LOCATION	;ZERO PAGE POINTER TO START ADDRESS
000000r 2               	JSR SAVE	;APPEND TO FILE X/Y=END ADDRESS
000000r 2               	LDA #$01
000000r 2               	JSR CLOSE	;CLOSE FILE
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ;MACRO SET_VERA_ADDR X = VERA_L, Y = VERA_M, A = VERA_H
000000r 2               .MACRO SET_VERA_ADDR
000000r 2               	STX $9F20
000000r 2               	STY $9F21
000000r 2               	STA $9F22
000000r 2               .ENDMACRO
000000r 2               
000000r 1               .INCLUDE "x16.inc"
000000r 2               ; X16 ADDRESSES, VALUES, AND MACROS
000000r 2               ; ACCURATE FOR ROM RELEASE R47
000000r 2               
000000r 2               SD_DEVICE   := 8
000000r 2               DISK_DEVICE := SD_DEVICE ; CHANGE IF LOADING FROM IEC DEVICE
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; KERNAL VECTORS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; STANDARD VECTORS
000000r 2               CINV    := $0314 ; IRQ INTERRUPT ROUTINE
000000r 2               CBINV   := $0316 ; BRK INSTRUCTION INTERRUPT
000000r 2               NMINV   := $0318 ; NON-MASKABLE INTERRUPT
000000r 2               IOPEN   := $031A ; KERNAL OPEN ROUTINE
000000r 2               ICLOSE  := $031C ; KERNAL CLOSE ROUTINE
000000r 2               iCHKIN  := $031E ; KERNAL CHKIN ROUTINE
000000r 2               ICKOUT  := $0320 ; KERNAL CKOUT ROUTINE
000000r 2               ICLRCH  := $0322 ; KERNAL CLRCHN ROUTINE
000000r 2               IBASIN  := $0324 ; KERNAL CHRIN ROUTINE
000000r 2               IBSOUT  := $0326 ; KERNAL CHROUT ROUTINE
000000r 2               ISTOP   := $0328 ; KERNAL STOP ROUTINE
000000r 2               IGETIN  := $032A ; KERNAL GETIN ROUTINE
000000r 2               ICLALL  := $032C ; KERNAL CLALL ROUTINE
000000r 2               ILOAD   := $0330 ; KERNAL LOAD ROUTINE
000000r 2               ISAVE   := $0332 ; KERNAL SAVE ROUTINE
000000r 2               
000000r 2               ; 65C816 VECTORS
000000r 2               IECOP   := $0334 ; COP INSTRUCTION INTERRUPT ROUTINE (EMULATION MODE)
000000r 2               IEABORT := $0336 ; ABORT ROUTINE (EMULATION MODE)
000000r 2               INIRQ   := $0338 ; IRQ INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INBRK   := $033A ; BRK INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INNMI   := $033C ; NON-MASKABLE INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INCOP   := $033E ; COP INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INABORT := $0340 ; ABORT ROUTINE (NATIVE MODE)
000000r 2               
000000r 2               ; FRAMEBUFFER VECTORS
000000r 2               I_FB_INIT                   := $02E4 ; FRAMEBUFFER ENABLE ROUTINE
000000r 2               I_FB_GET_INFO               := $02E6 ; FRAMEBUFFER INFO ROUTINE
000000r 2               I_FB_SET_PALETTE            := $02E8 ; FRAMEBUFFER PALETTE ROUTINE
000000r 2               I_FB_CURSOR_POSITION        := $02EA ; FRAMEBUFFER CURSOR POSITION ROUTINE
000000r 2               I_FB_CURSOR_NEXT_LINE       := $02EC ; FRAMEBUFFER NEXT LINE ROUTINE
000000r 2               I_FB_GET_PIXEL              := $02EE ; FRAMEBUFFER COPY PIXEL ROUTINE
000000r 2               I_FB_GET_PIXELS             := $02F0 ; FRAMEBUFFER COPY PIXELS ROUTINE
000000r 2               I_FB_SET_PIXEL              := $02F2 ; FRAMEBUFFER SET PIXEL ROUTINE
000000r 2               I_FB_SET_PIXELS             := $02F4 ; FRAMEBUFFER SET PIXELS ROUTINE
000000r 2               I_FB_SET_8_PIXELS           := $02F6 ; FRAMEBUFFER SET 8 PIXELS ROUTINE
000000r 2               I_FB_SET_8_PIXELS_OPAQUE    := $02F8 ; FRAMEBUFFER SET 8 OPAQUE PIXELS ROUTINE
000000r 2               I_FB_FILL_PIXELS            := $02FA ; FRAMEBUFFER FILL PIXELS ROUTINE
000000r 2               I_FB_FILTER_PIXELS          := $02FC ; FRAMEPUFFER TRANSFORM PIXELS ROUTINE
000000r 2               I_FB_MOVE_PIXELS            := $02FE ; FRAMEBUFFER MOVE PIXELS ROUTINE
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; KERNAL API FUNCTIONS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; PERIPHERAL BUS
000000r 2               ACPTR   := $FFA5 ; READ A BYTE FROM THE PERIPHERAL BUS
000000r 2               MACPTR  := $FF44 ; READ MULTIPLE BYTES FROM THE PERIPHERAL BUS
000000r 2               MCIOUT  := $FEB1 ; WRITE MULTIPLE BYTES TO THE PERIPHERAL BUS
000000r 2               
000000r 2               ; CHANNEL I/O
000000r 2               BSAVE   := $FEBA ; SAVE AN AREA OF MEMORY TO A FILE WITHOUT WRITING AN ADDRESS HEADER
000000r 2               CLOSE   := $FFC3 ; CLOSE A LOGICAL FILE
000000r 2               LOAD    := $FFD5 ; LOAD THE CONTENTS OF A FILE FROM DISK TO MEMORY
000000r 2               OPEN    := $FFC0 ; OPENS A CHANNEL/FILE
000000r 2               SAVE    := $FFD8 ; SAVE AN AREA OF MEMORY TO A FILE
000000r 2               SETFLS  := $FFBA ; SET FILE PARAMETERS
000000r 2               SETNAM  := $FFBD ; SET FILE NAME
000000r 2               
000000r 2               ; MEMORY
000000r 2               MEMORY_FILL         := $FEE4 ; FILL MEMORY REGION WITH A BYTE VALUE
000000r 2               MEMORY_COPY         := $FEE7 ; COPY MEMORY REGION
000000r 2               MEMORY_CRC          := $FEEA ; CALCULATE CRC16 OF MEMORY REGION
000000r 2               MEMORY_DECOMPRESS   := $FEED ; DECOMPRESS LZSA2 BLOCK
000000r 2               FETCH               := $FF74 ; READ A BYTE FROM ANY RAM OR ROM BANK
000000r 2               STASH               := $FF77 ; WRITE A BYTE TO ANY RAM BANK
000000r 2               MEMTOP              := $FF99 ; GET NUMBER OF BANKS AND ADDRESS OF END OF USABLE RAM
000000r 2               
000000r 2               ; CLOCK
000000r 2               CLOCK_SET_DATE_TIME := $FF4D ; SET DATE AND TIME OF THE RTC
000000r 2               CLOCK_GET_DATE_TIME := $FF50 ; GET DATE AND TIME FROM THE RTC
000000r 2               RDTIM               := $FFDE ; READ SYSTEM CLOCK FROM THE VIA
000000r 2               
000000r 2               ; KEYBOARD
000000r 2               KBDBUF_PEEK             := $FEBD ; GET FIRST CHARACTER IN KEYBOARD QUEUE AND QUEUE LENGTH
000000r 2               KBDBUF_GET_MODIFIERS    := $FEC0 ; GET CURRENTLY PRESSED MODIFIER KEYS
000000r 2               KBDBUF_PUT              := $FEC3 ; APPEND A CHARACTER TO THE KEYBOARD QUEUE
000000r 2               KEYMAP                  := $FED2 ; SET OR GET THE CURRENT KEYBOARD LAYOUT
000000r 2               KBD_SCAN                := $FF9F ; READ A KEYCODE PREVIOUSLY FETCHED FROM THE SMC, APPLY KEYMAP LOCALIZATION, AND ADD IT THE THE X16'S BUFFER
000000r 2               
000000r 2               ; MOUSE
000000r 2               MOUSE_CONFIG    := $FF68 ; CONFIGURE THE MOUSE POINTER
000000r 2               MOUSE_SCAN      := $FF71 ; QUERY THE MOUSE AND SAVE ITS STATE
000000r 2               MOUSE_GET       := $FF6B ; GET THE MOUSE STATE
000000r 2               
000000r 2               ; JOYSTICK
000000r 2               JOYSTICK_SCAN   := $FF53 ; QUERY THE JOYSTICKS AND SAVE THEIR STATE
000000r 2               JOYSTICK_GET    := $FF56 ; GET THE STATE OF ONE OF THE JOYSTICKS
000000r 2               
000000r 2               ; I2C
000000r 2               I2C_BATCH_READ  := $FEB4 ; READ BYTES FROM A GIVE I2C DEVICE INTO A RAM LOCATION
000000r 2               I2C_BATCH_WRITE := $FEB7 ; WRITE BYTES TO A GIVEN I2C DEVICE WITH DATA IN RAM
000000r 2               I2C_READ_BYTE   := $FEC6 ; READ A BYTE AT A GIVEN OFFSET FROM A GIVEN I2C DEVICE
000000r 2               I2C_WRITE_BYTE  := $FEC9 ; WRITE A BYTE AT A GIVEN OFFSET TO A GIVEN I2C DEVICE
000000r 2               
000000r 2               ; SPRITES
000000r 2               SPRITE_SET_IMAGE    := $FEF0 ; SET THE IMAGE OF A SPRITE
000000r 2               SPRITE_SET_POSITION := $FEF3 ; SET THE POSITION OF A SPRITE OR HIDE IT
000000r 2               
000000r 2               ; FRAMEBUFFER
000000r 2               FB_INIT                 := $FEF6 ; ENTER GRAPHICS MODE
000000r 2               FB_GET_INFO             := $FEF9 ; RETURN THE RESOLUTION AND COLOR DEPTH
000000r 2               FB_SET_PALETTE          := $FEFC ; SET (PARTS OF) THE PALETTE
000000r 2               FB_CURSOR_POSITION      := $FEFF ; POSITION THE DIRECT-ACCESS CURSOR
000000r 2               FB_CURSOR_NEXT_LINE     := $FF02 ; MOVE THE DIRECT-ACCESS CURSOR TO THE NEXT LINE
000000r 2               FB_GET_PIXEL            := $FF05 ; READ ONE PIXEL, UPDATE CURSOR
000000r 2               FB_GET_PIXELS           := $FF08 ; COPY PIXELS INTO RAM, UPDATE CURSOR
000000r 2               FB_SET_PIXEL            := $FF0B ; SET ONE PIXEL, UPDATE CURSOR
000000r 2               FB_SET_PIXELS           := $FF0E ; COPY PIXELS FROM RAM, UPDATE CURSOR
000000r 2               FB_SET_8_PIXELS         := $FF11 ; SET 8 PIXELS FROM BIT MASK (TRANSPARENT), UPDATE CURSOR
000000r 2               FB_SET_8_PIXELS_OPAQUE  := $FF14 ; SET 8 PIXELS FROM BIT MASK (OPAQUE), UPDATE CURSOR
000000r 2               FB_FILL_PIXELS          := $FF17 ; FILL PIXELS WITH CONSTANT COLOR, UPDATE CURSOR
000000r 2               FB_FILTER_PIXELS        := $FF1A ; APPLY TRANSFORM TO PIXELS, UPDATE CURSOR
000000r 2               FB_MOVE_PIXELS          := $FF1D ; COPY HORIZONTALLY CONSECUTIVE PIXELS TO A DIFFERENT POSITION
000000r 2               
000000r 2               ; GRAPHICS
000000r 2               GRAPH_INIT          := $FF02 ; ACTIVATE FRAMEBUFFER DRIVER, ENTER AND INITIALIZE GRAPHICS MODE
000000r 2               GRAPH_CLEAR         := $FF23 ; CLEAR THE CURRENT WINDOW WITH THE CURRENT BACKGROUND COLOR
000000r 2               GRAPH_SET_WINDOW    := $FF26 ; SET THE CLIPPING REGION
000000r 2               GRAPH_SET_COLORS    := $FF29 ; SET THE THREE COLORS
000000r 2               GRAPH_DRAW_LINE     := $FF2C ; DRAW A LINE USING THE STROKE COLOR
000000r 2               GRAPH_DRAW_RECT     := $FF2F ; DRAW A RECTANGLE
000000r 2               GRAPH_MOVE_RECT     := $FF23 ; COPY A RECTANGLULAR SCREEN AREA TO A DIFFERENT LOCATION
000000r 2               GRAPH_DRAW_OVAL     := $FF35 ; DRAW AN OVAL OR A CIRCLE
000000r 2               GRAPH_DRAW_IMAGE    := $FF38 ; DRAW A RECTANGULAR IMAGE FROM DATA IN MEMORY
000000r 2               GRAPH_SET_FONT      := $FF3B ; SET THE CURRENT FONT
000000r 2               GRAPH_GET_CHAR_SIZE := $FF3E ; GET THE SIZE AND BASELINE OF A CHARACTER, OR INTERPRET A CONTROL CODE
000000r 2               GRAPH_PUT_CHAR      := $FF41 ; PRINT A CHARACTER ONTO THE GRAPHICS SCREEN
000000r 2               
000000r 2               ; CONSOLE
000000r 2               CONSOLE_INIT                := $FEDB ; INITIALIZE CONSOLE MODE
000000r 2               CONSOLE_PUT_CHAR            := $FEDE ; PRINT A CHARACTER TO THE CONSOLE
000000r 2               CONSOLE_PUT_IMAGE           := $FED8 ; DRAW IMAGE AS IF IT WAS A CHARACTER
000000r 2               CONSOLE_GET_CHAR            := $FEE1 ; GET A CHARACTER FROM THE CONSOLE
000000r 2               CONSOLE_SET_PAGING_MESSAGE  := $FED5 ; SET THE PAGING MESSAGE OR DISABLE PAGING
000000r 2               
000000r 2               ; MISC
000000r 2               ENTER_BASIC         := $FF47 ; ENTER BASIC
000000r 2               ENTROPY_GET         := $FECF ; GET 24 RANDOM BITS
000000r 2               MONITOR             := $FECC ; ENTER MACHINE LANGUAGE MONITOR
000000r 2               SCREEN_MODE         := $FF5F ; GET/SET SCREEN MODE
000000r 2               SCREEN_SET_CHARSET  := $FF62 ; ACTIVATE 8x8 TEXT MODE CHARSET
000000r 2               SCREEN              := $FFED ; GET THE TEXT RESOLUTION OF THE SCREEN
000000r 2               
000000r 2               ; EXTENDED API
000000r 2               EXTAPI                  := $FEAB ; EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
000000r 2               ; A-VALUES
000000r 2               CLEAR_STATUS            := $01 ; RESETS THE KERNAL IEC STATUS TO ZERO
000000r 2               GETLFS                  := $02 ; GETTER COUNTERPART TO SETLFS
000000r 2               MOUSE_SPRITE_OFFSET     := $03 ; GET OR SET MOUSE SPRITE PIXEL OFFSET
000000r 2               JOYSTICK_PS2_KEYCODES   := $04 ; GET OR SET JOY0 KEYCODE MAPPINGS
000000r 2               ISO_CURSOR_CHAR         := $05 ; GET OR SET THE ISO MODE CURSOR CHARACTER
000000r 2               PS2KBD_TYPEMATIC        := $06 ; SET THE KEYBOARD REPEAT DELAY AND RATE
000000r 2               PFKEY                   := $07 ; PROGRAM MACROS FOR THE F1-F8 AND THE RUN KEY
000000r 2               PS2DATA_FETCH           := $08 ; POLLS THE SMC FOR PS/2 KEYBOARD AND MOUSE DATA
000000r 2               FS2DATA_RAW             := $09 ; IF THE POST RECENT PS2DATA_FETCH RECEIVED A MOUSE PACKET OR KEYCODE, RETURNS ITS RAW VALUE
000000r 2               CURSOR_BLINK            := $0A ; BLINKS OR UN-BLINKS THE KERNAL EDITOR CURSOR IF APPROPRIATE
000000r 2               LED_UPDATE              := $0B ; ILLUMINATES OR CLEARS THE SMC ACTIVITY LED BASED ON DISK ACTIVITY OR ERROR STATUS
000000r 2               MOUSE_SET_POSITION      := $0C ; MOVES THE MOUSE CURSOR TO A SPECIFIC X/Y LOCATION
000000r 2               SCNSIZ                  := $0D ; DIRECTLY SETS THE KERNAL EDITOR TEXT DIMENSIONS
000000r 2               
000000r 2               ; 65C816 EXTENDED API
000000r 2               EXTAPI16                := $FEA8 ; 65C816 EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
000000r 2               ; A-VALUES
000000r 2               TEST                        := $00 ; USED BY UNIT TESTS FOR JSRFAR
000000r 2               STACK_PUSH                  := $01 ; POINTS THE STACK POINTER TO A NEW STACK
000000r 2               STACK_POP                   := $02 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED STACK
000000r 2               STACK_ENTER_KERNAL_STACK    := $03 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED $01xx STACK, PRESERVING THE CURRENT ONE
000000r 2               STACK_LEAVE_KERNAL_STACK    := $04 ; POINT THE STACK POINTER TO THE PREVIOUSLY-PRESERVED STACK
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; I/O REGISTERS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; VERA REGISTERS
000000r 2               VERA_L			= $9F20
000000r 2               VERA_M			= $9F21
000000r 2               VERA_H			= $9F22
000000r 2               VERA_DATA0		= $9F23
000000r 2               VERA_DATA1      = $9F24
000000r 2               VERA_CTRL       = $9F25
000000r 2               VERA_IEN 		= $9F26
000000r 2               VERA_ISR 		= $9F27
000000r 2               VIDEO_CONFIG	= $9F29 ; (DCSEL = 0)
000000r 2               L0_CONFIG 		= $9F2D
000000r 2               L0_MAPBASE		= $9F2E
000000r 2               L0_TILEBASE		= $9F2F
000000r 2               L0_HSCROLL_L	= $9F30
000000r 2               L0_HSCROLL_H	= $9F31
000000r 2               L0_VSCROLL_L	= $9F32
000000r 2               L0_VSCROLL_H	= $9F33
000000r 2               L1_CONFIG 		= $9F34
000000r 2               L1_MAPBASE 		= $9F35
000000r 2               L1_TILEBASE		= $9F36
000000r 2               L1_HSCROLL_L	= $9F37
000000r 2               L1_HSCROLL_H	= $9F38
000000r 2               L1_VSCROLL_L	= $9F39
000000r 2               L1_VSCROLL_H	= $9F3A
000000r 2               
000000r 2               
000000r 1               .INCLUDE "serial.inc"
000000r 2               ; The SERIAL RS232 IO base, which depends on the IO and Hi/Lo jumper settings on the card.
000000r 2               IO_BASE = $9FE8
000000r 2               
000000r 2               RX_BUFFER           = IO_BASE               ;READ ONLY
000000r 2               TX_HOLDING          = IO_BASE               ;WRITE ONLY
000000r 2               INTERRUPT_ENABLE    = IO_BASE + 1
000000r 2               INTERRUPT_IDENT     = IO_BASE + 2           ;READ ONLY
000000r 2               FIFO_CONTROL        = IO_BASE + 2           ;WRITE ONLY
000000r 2               LINE_CONTROL        = IO_BASE + 3
000000r 2               MODEM_CONTROL       = IO_BASE + 4
000000r 2               LINE_STATUS         = IO_BASE + 5
000000r 2               MODEM_STATUS        = IO_BASE + 6
000000r 2               SCRATCH             = IO_BASE + 7
000000r 2               
000000r 2               ; Used to set baud rate by setting Divsor Latch to 1 (LINE_STATUS)
000000r 2               DIVISOR_LATCH_LOW   = IO_BASE
000000r 2               DIVISOR_LATCH_HI    = IO_BASE + 1
000000r 2               
000000r 2               
000000r 2               ;; Line Control Register Flags
000000r 2               ; Bit 7				: Divisor Latch
000000r 2               ; Bit 6				: Break Control
000000r 2               ; Bit 5				: Sticky Parity
000000r 2               ; Bit 4				: Parity Select
000000r 2               ; Bit 3				: Parity Enable (0 for none)
000000r 2               ; Bit 2				: Stop Bits (0 to 1 stop bit)
000000r 2               ; Bits 0 & 1	: Word Length (both to 1 = 8-bits)
000000r 2               ; No Partity, 1 Stop, 8-Bits
000000r 2               LCR_SETUP  = %00000011
000000r 2               
000000r 2               ;; Interrupt Enable Flags
000000r 2               ; Bits 7-4		: Unused (always cleared)
000000r 2               ; Bit 3				: 1 = Enable Modem Status Interrupt
000000r 2               ; Bit 2				: 1 = Enable Receiver Line Status Intterupt
000000r 2               ; Bit 1				: 1 = Enable THRE (Transmission Holding Register) Interrupt
000000r 2               ; Bit 0				: 1 = Enable Received Data Available Interrupt
000000r 2               INTR_SETUP = %00000001
000000r 2               
000000r 2               ;; FIFO Control Register Flags
000000r 2               ; Bits 7-6		: Buffer size (00 = $01, 01 = $04, 10 = $08, 11 = $0E)
000000r 2               ; Bits 5-4		: Reserved
000000r 2               ; Bit 3				: When FCR0 set, assert !RXRDY and !TXRDY pins
000000r 2               ; Bit 2				: Clears TX FIFO and counter
000000r 2               ; Bit 1				: Clears RX FIFO and counter
000000r 2               ; Bit 0				: Enable FIFO Buffers
000000r 2               FIFO_SETUP = %11000111
000000r 2               
000000r 2               ;BAUD_RATE_DIVISOR = $0025
000000r 2               ; 9600 (for testing 9-pin RS232)
000000r 2               ;BAUD_RATE_DIVISOR = $0079
000000r 2               ; 2400
000000r 2               ;BAUD_RATE_DIVISOR = $01E0
000000r 2               ; 9600 (for testing 9-pin RS232)
000000r 2               BAUD_RATE_DIVISOR = $0001
000000r 2               
000000r 2               ;;ADDRESS WHERE THE LOW RAM SERIAL VALUE IS STORED
000000r 2               STORE_ADDR = $22
000000r 2               
000000r 2               ;; BANK WHERE THE SERIAL VALUE IS STORED
000000r 2               STORE_BANK = $24
000000r 2               
000000r 2               ;;POINTER TO SAVE START ADDRESS
000000r 2               SAVE_ADDR = $26
000000r 2               
000000r 1               .SEGMENT "LOADADDR"
000000r 1  01 08        	.WORD $0801
000002r 1               .SEGMENT "BASICSTUB"
000000r 1  rr rr        	.WORD START-2
000002r 1  00 00 9E     	.BYTE $00,$00,$9E
000005r 1  32 30 36 31  	.BYTE "2061"
000009r 1  00 00 00     	.BYTE $00,$00,$00
00000Cr 1               .SEGMENT "STARTUP"
000000r 1               START:
000000r 1  4C rr rr     	JMP MAIN
000003r 1               .SEGMENT "CODE"
000000r 1               ;; USE cat BUILD.PRG > /dev/ttyUSB0 TO SEND FILE
000000r 1               MAIN:
000000r 1  20 rr rr     	JSR INIT_IRQ
000003r 1  20 rr rr     	JSR SETUP
000006r 1  20 rr rr     	JSR UART_SETUP
000009r 1  60           	RTS
00000Ar 1               SETUP:
00000Ar 1  A9 FF        	LDA	#$FF					;SET STORE ADDRESS TO $A000
00000Cr 1  85 22        	STA STORE_ADDR
00000Er 1  A9 9F        	LDA #$9F
000010r 1  85 23        	STA STORE_ADDR + 1
000012r 1  A9 01        	LDA #$01					;SET STORE BANK TO 1
000014r 1  85 24        	STA STORE_BANK
000016r 1  64 26        	STZ SAVE_ADDR				;SET SAVE ADDRESS TO $A000
000018r 1  A9 A0        	LDA #$A0
00001Ar 1  85 27        	STA SAVE_ADDR + 1
00001Cr 1               	;TEMPORARY FOR TESTING
00001Cr 1  64 02        	STZ $0002
00001Er 1  A9 80        	LDA #$80
000020r 1  85 03        	STA $0003
000022r 1  64 04        	STZ $0004
000024r 1  A9 01        	LDA #$01
000026r 1  85 05        	STA $0005
000028r 1  A9 00        	LDA #$00
00002Ar 1  20 E4 FE     	JSR MEMORY_FILL
00002Dr 1               	;TEMPORARY FOR TESTING
00002Dr 1  60           	RTS
00002Er 1               UART_SETUP:
00002Er 1  A9 01        	LDA #INTR_SETUP				;ENABLE THE DATA READY INTERRUPT ON THE UART
000030r 1  8D E9 9F     	STA INTERRUPT_ENABLE
000033r 1  A9 C7        	LDA #FIFO_SETUP				;ENABLE FIFO BUFFER
000035r 1  8D EA 9F     	STA FIFO_CONTROL
000038r 1  A9 80        	LDA #%10000000				;SETS BAUD RATE DIVISOR TO 1
00003Ar 1  8D EB 9F     	STA LINE_CONTROL
00003Dr 1  A9 01        	LDA #<BAUD_RATE_DIVISOR
00003Fr 1  8D E8 9F     	STA DIVISOR_LATCH_LOW
000042r 1  A9 00        	LDA #>BAUD_RATE_DIVISOR
000044r 1  8D E9 9F     	STA DIVISOR_LATCH_HI
000047r 1  A9 03        	LDA #LCR_SETUP				;SETS WORD LENGTH TO 8 BITS
000049r 1  8D EB 9F     	STA LINE_CONTROL
00004Cr 1  A9 23        	LDA #%00100011				;MAKES UART READY TO SEND AND RECIEVE DATA
00004Er 1  8D EC 9F     	STA MODEM_CONTROL			;ALSO ENABLE AUTOFLOW CONTROL
000051r 1  60           	RTS
000052r 1  00 00        DEFAULT_IRQ: .ADDR 0
000054r 1               IRQ_HANDLING:
000054r 1               	INIT_IRQ:
000054r 1  AD 14 03     		LDA CINV				;SAVE THE DEFAULT IRQ POINTER
000057r 1  8D rr rr     		STA DEFAULT_IRQ
00005Ar 1  AD 15 03     		LDA CINV+1
00005Dr 1  8D rr rr     		STA DEFAULT_IRQ+1
000060r 1  78           		SEI						;DISABLE INTERRUPTS
000061r 1  A9 rr        		LDA #<CUSTOM_IRQ		;REPLACE IRQ POINTER WITH CUSTOM POINTER
000063r 1  8D 14 03     		STA CINV
000066r 1  A9 rr        		LDA #>CUSTOM_IRQ
000068r 1  8D 15 03     		STA CINV+1
00006Br 1  58           		CLI						;RE-ENABLE INTERRUPTS
00006Cr 1  60           		RTS
00006Dr 1               	CUSTOM_IRQ:
00006Dr 1  20 rr rr     		JSR SERIAL_IRQ
000070r 1  6C rr rr     		JMP (DEFAULT_IRQ)
000073r 1               	SERIAL_IRQ:
000073r 1  9C rr rr     		STZ TMP	;TEMPORARY FOR TESTING
000076r 1  AD EA 9F     		LDA INTERRUPT_IDENT		;DETERMINE IF INTERRUPT IS CAUSED BY UART
000079r 1  29 0C        		AND #%00001100
00007Br 1  C9 04        		CMP #%00000100
00007Dr 1  F0 0A        		BEQ TRANSFER_DATA
00007Fr 1               		;TEMPORARY FOR TESTING
00007Fr 1  A0 01        		LDY #$01
000081r 1  8C rr rr     		STY TMP
000084r 1  C9 0C        		CMP #%00001100
000086r 1  F0 01        		BEQ TRANSFER_DATA
000088r 1               		;TEMPORARY FOR TESTING
000088r 1  60           		RTS
000089r 1               TRANSFER_DATA:
000089r 1               		;TEMPORARY FOR TESTING
000089r 1  AD EA 9F     		LDA INTERRUPT_IDENT
00008Cr 1  8D rr rr     		STA INTR
00008Fr 1  20 rr rr     		JSR LOG
000092r 1               		;TEMPORARY FOR TESTING
000092r 1  A5 22        		LDA STORE_ADDR				;INCREMENT THE STORE ADDRESS POINTER LOW BYTE
000094r 1  1A           		INC
000095r 1  85 22        		STA STORE_ADDR
000097r 1  C9 00        		CMP #$00					;IF THE POINTER OVERFLOWED CONTINUE
000099r 1  D0 12        		BNE @STORE_DATA
00009Br 1  A5 23        		LDA STORE_ADDR + 1			;INCREMENT THE STORE ADDRESS POINTER HIGH BYTE
00009Dr 1  1A           		INC
00009Er 1  85 23        		STA STORE_ADDR + 1
0000A0r 1  C9 C0        		CMP #$C0					;IF THE HIGH BYTE IS $C0, THEN CONTINUE
0000A2r 1  D0 09        		BNE @STORE_DATA
0000A4r 1  A5 24        		LDA STORE_BANK				;INCREMENT THE BANK TO STORE THE DATA
0000A6r 1  1A           		INC
0000A7r 1  85 24        		STA STORE_BANK
0000A9r 1  A9 A0        		LDA #$A0
0000ABr 1  85 23        		STA STORE_ADDR + 1			;RESET THE STORE ADDRESS POINTER
0000ADr 1               	@STORE_DATA:
0000ADr 1  A5 24        		LDA STORE_BANK				;SET THE BANK TO STORE THE DATA
0000AFr 1  85 00        		STA $00
0000B1r 1  AD E8 9F     		LDA RX_BUFFER				;READ DATA FROM THE UART AND STORE IT TO BANKED RAM
0000B4r 1  92 22        		STA (STORE_ADDR)
0000B6r 1               		;TEMPORARY FOR TESTING
0000B6r 1  AD rr rr     		LDA TMP
0000B9r 1  C9 01        		CMP #$01
0000BBr 1  D0 21        		BNE @DETECT_DATA
0000BDr 1  A9 FF        		LDA #$FF
0000BFr 1  8D rr rr     		STA INTR
0000C2r 1  20 rr rr     		JSR LOG
0000C5r 1  60           		RTS
0000C6r 1               		;TEMPORARY FOR TESTING
0000C6r 1               	@DISPLAY_LOADING:
0000C6r 1  AD ED 9F     		LDA LINE_STATUS				;CHECK IF ALL DATA HAS BEEN SENT
0000C9r 1  29 01        		AND #%00000001
0000CBr 1  C9 01        		CMP #$01
0000CDr 1  F0 0F        		BEQ @DETECT_DATA			;IF ALL DATA HAS BEEN SENT CONTINUE
0000CFr 1  AD 22 9F     		LDA VERA_H
0000D2r 1  09 21        		ORA #%00100001				;SET VERA AUTOINCREMENT TO 2
0000D4r 1  29 21        		AND #%00100001
0000D6r 1  8D 22 9F     		STA VERA_H
0000D9r 1  A9 66        		LDA #$66					;PRINT CHARACTER $66 TO SCREEN
0000DBr 1  8D 23 9F     		STA VERA_DATA0
0000DEr 1               	@DETECT_DATA:
0000DEr 1  AD ED 9F     		LDA LINE_STATUS				;IF THERE IS STILL DATA IN THE FIFO
0000E1r 1  09 FE        		ORA #%11111110				;KEEP READING AND STORING THE DATA
0000E3r 1  C9 FF        		CMP #$FF
0000E5r 1  F0 A2        		BEQ TRANSFER_DATA
0000E7r 1  60           		RTS
0000E8r 1               
0000E8r 1               ;TEMPORARY FOR TESTING
0000E8r 1  00           INTR:	.BYTE $00
0000E9r 1  00           CNT: .BYTE $00
0000EAr 1  00           TMP:	.BYTE $00
0000EBr 1               LOG:
0000EBr 1  AD rr rr     		LDA CNT
0000EEr 1  C9 FF        		CMP #$FF
0000F0r 1  F0 0D        		BEQ @RETURN
0000F2r 1  AE rr rr     		LDX CNT
0000F5r 1  AD rr rr     		LDA INTR
0000F8r 1  9D 00 80     		STA $8000,X
0000FBr 1  E8           		INX
0000FCr 1  8E rr rr     		STX CNT
0000FFr 1               	@RETURN:
0000FFr 1  60           		RTS
000100r 1               ;TEMPORARY FOR TESTING
000100r 1               
